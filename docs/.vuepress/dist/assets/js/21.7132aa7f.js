(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{387:function(a,e,t){"use strict";t.r(e);var n=t(45),s=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"插件介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#插件介绍"}},[a._v("#")]),a._v(" 插件介绍")]),a._v(" "),t("p",[a._v("Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如 EHCache 或者 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。")]),a._v(" "),t("p",[a._v("Spring 的缓存技术还具备相当的灵活性，不仅能够使用 SpEL（Spring Expression Language）来定义缓存的 key 和各种 condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如 EHCache 集成。")]),a._v(" "),t("p",[a._v("其特点总结如下：")]),a._v(" "),t("p",[a._v("通过少量的配置 annotation 注释即可使得既有代码支持缓存\n支持开箱即用 Out-Of-The-Box，即不用安装和部署额外第三方组件即可使用缓存\n支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition\n支持 AspectJ，并通过其实现任何方法的缓存支持\n支持自定义 key 和自定义缓存管理者，具有相当的灵活性和扩展性")]),a._v(" "),t("h2",{attrs:{id:"使用说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用说明"}},[a._v("#")]),a._v(" 使用说明")]),a._v(" "),t("p",[a._v("当前支持两种实现的内存缓存，一种是通过caffeine（推荐使用）实现，另外一种是通过redis实现。")]),a._v(" "),t("h2",{attrs:{id:"配置步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置步骤"}},[a._v("#")]),a._v(" 配置步骤")]),a._v(" "),t("ol",[t("li",[a._v("添加pom依赖")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("    <dependency>\n        <groupId>com.ichinae.core.plugins</groupId>\n        <artifactId>ichinae-core-plugins-cache</artifactId>\n        <version>1.0.0</version>\n    </dependency>\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[a._v("在启动类引入：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("@Import({CacheConfiguration.class})\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[a._v("在配置文件中，加入配置")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("    spring:\n        cache:\n        # cache的名称，必须配置。可以配置多个名称，如果是多个的话，使用英文逗号隔开不加空格。\n        - name: test \n        type: caffeine\n        # cache的最大容量，如果不配的话，使用默认：10000\n        maximumSize: 10000\n        # cache的初始化容量，如果不配的话，使用默认：5000\n        initialCapacity: 5000\n        # cache的过期时间，如果不配的话，使用默认：300 单位为秒\n        expireAfterAccess: 300\n        - name: test \n        type: redis\n        # cache的最大容量，如果不配的话，使用默认：10000\n        maximumSize: 10000\n        # cache的初始化容量，如果不配的话，使用默认：5000\n        initialCapacity: 5000\n        # cache的过期时间，如果不配的话，使用默认：300 单位为秒\n        expireAfterAccess: 300\n")])])]),t("p",[a._v("如果使用redis的话，需要增加redis的连接配置")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("    spring:\n            redis:\n            host: localhost\n            port: 6379\n")])])]),t("h2",{attrs:{id:"使用介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用介绍"}},[a._v("#")]),a._v(" 使用介绍")]),a._v(" "),t("ol",[t("li",[a._v("通过添加@Cacheable()实现功能"),t("br"),a._v("注解中要设置 value,key,condition\n如果想要使用redis的话，需要在@Cacheable()中额外添加 cacheManager = CacheConst.REDIS_CACHE_MANAGER\n如果要是在配置文件中没有指定name的话，需要设置value = CacheConst.DEFAULT_CACHE_NAME")]),a._v(" "),t("li",[a._v("@CachePut,@CacheEvict 都可以按照常规的使用规则进行使用")])])])}),[],!1,null,null,null);e.default=s.exports}}]);