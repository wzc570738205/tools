## 插件说明
没有规矩不成方圆，为了统一标准接口数据格式，统一监控追踪，统一编码规范，统一代码生成机制等，集团所有Java项目须引入common公共核心插件。<br>
集团框架核心包，所有集团后端项目须引入该核心插件。主要功能有：
* 提供Controller，Service, DAO(Mapper)等基类，规范开发标准，若需链路监控或框架提供的其他扩展功能，必须继承这些父类。
* 提供完善的异常管理和统一异常处理能力。
* 提供Response输出，便于跨项目间数据访问。
* 提供Domain模型封装，对Entity实体，DTO，Domain等模型提供规范，并提供实体与DTO快速转换机制。
* 对Mybatis-plus进行了封装，并提供了快捷的分页实现机制。
* 框架提供统一后台任务与多线程处理机制，Spring事件监听机制。
* 提供链路追踪监控功能，对每一个请求出入参，异常堆栈，耗时等关键信息自动捕捉，便于问题定位解决。
* 跨域访问提供开关支持。
* 标准Swagger文档支持。
* 完善的Log日志管理和操作日志管理能力。
* 与集团脚手架项目无缝集成。
* 对Spring Cloud Alibaba分布式框架天然支持，快速实现分布式项目部署。

框架基于SpringBoot搭建，全面支持Spring Cloud Alibaba微服务架构。

## 配置步骤
框架对应的SpringBoot对应版本为2.1.2.RELEASE。
1. 项目中需要引入parent依赖，引入框架体系framework-core。
````
    <parent>
        <groupId>com.ichinae.framework</groupId>
        <artifactId>framework-core</artifactId>
        <version>1.0.0</version>
    </parent>
````
2. 核心插件为ichinae-core-plugins-common插件，期版本已在parent依赖中统一管理，POM依赖中无需添加版本信息。
````
    <dependency>
        <groupId>com.ichinae.core.plugins</groupId>
        <artifactId>ichinae-core-plugins-common</artifactId>
    </dependency>
````


## 启动类规则

1. 项目Application启动类配置如下
````
@BaseBootApplication
@SpringBootApplication
@MapperScan({"com.ichinae.**.mapper*"})
@ComponentScan(basePackages = {"com.ichinae.*"})
````
2. 使用跨域，需要手动注入处理类
````
@Import({CorsConfig.class})
````

## API接口规范
没有规矩不成方圆，为了统一项目间的调用返回，统一开发标准，统一API文档，统一代码生成机制等，定制如下API接口开发标准。
1. 所有接口均返回Response对象
2. 数据库对应实体类Entity须集成BaseEntity
3. 出参Response的data对象，继承BaseDTO或BaseDomain
4. 分页入参继承Page
5. 分页出参Response的data对象是Page对象
6. Response在Controller返回中定义，不要在Service中返回Response对象，Service中直接返回如List，Map，Data等业务数据。若有异常则按下规则直接抛出异常，不要捕获异常信息，框架会自动对异常进行统一处理。
7. 正常Response返回
````
{
    "success":true,
    "resultCode":"200",
    "message":"",
    "time":"2020-12-03 19:13:20",
    "data":[
        {
            "menuCode":"userPermissions",
            "menuName":"用户权限"
        }
    ]
}
````
## 对象处理
1. 数据库访问实体对象继承BaseEntity，并引入@Table标记数据库表名，@Data生成Get/Set方法
````
package com.ichinae.base.mgr.data.entity;

import com.baomidou.mybatisplus.annotations.TableId;
import com.baomidou.mybatisplus.enums.IdType;
import com.ichinae.core.plugins.common.model.entity.BaseEntity;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;
...

@Data
@Table(name = "sys_log")
public class SysLog extends BaseEntity {

	...

	/**
	 * 主键标识
	 */
	@ApiModelProperty(value = "主键")
	private Long id;

    ...
````
2. DTO类须继承BaseDTO
3. 若分页处理，入参须传入Page的子类。
4. Entity与DTO转换可调用toDomain方法直接转换
````
    SysDeptDTO sysDeptDTO = sysDept.toDomain(SysDeptDTO.class);
````
5. 框架支持JSR303规范，可进行入参校验。如下代码：
````
    @Data
public class User extends BaseEntity {

    @TableId(value="id", type= IdType.AUTO)
    private Long id;

    @NotBlank(message = "username不能为空")
    private String username;

    @NotBlank(message = "password不能为空")
    private String password;
````
调用接口必须用@Valid修饰，注意必须在Controller层中，在Service中无效。
````
    @PostMapping("/auth")
    @ApiOperation(value = "登录", notes = "登录")
    public Response<String> authLogin(@RequestBody @Valid User user) throws Exception {
        return Response.data(loginService.authLogin(user));
    }
````
如上例所示，调用密码为空时，抛出标准异常如下：
````
    {
        "success": false,
        "resultCode": "400",
        "message": "password不能为空;",
        "time": "2020-12-23 17:55:23"
    }
````

## 异常处理
为了统一异常标准，便于异常统一监控管理，框架对异常进行了分类，各框架业务模块等按异常分类抛出对应的异常。<br>
主要异常说明如下，业务模块更关注BusinessException及其子异常。
| 异常分类 | 使用说明 |
|:--------|:--------|
| BaseException | 项目框架所有异常父类，继承于RuntimeException异常 |
| SystemException | 系统异常父类 |
| FrameworkInternalSystemException | 框架内部异常 |
| CodeCheckerException| 代码检查异常 |
| StandardSystemException | 标准系统异常 |
| BusinessException | 业务异常父类 |
| StandardBusinessException | 标准业务异常类，业务可直接抛出此异常或该异常的子异常 |
| BackgroundTaskExecutionException | 后台（异步）任务异常 |

业务开发中，我们需要定义异常编码ErrorCode，编写规范如下：
````
    /**
    * @author: 王坤
    * @date: 2020/09/24 10:16
    */
    public class ErrorCode{

        public static final BusinessExceptionDesc SYS_ROLE_DEL = new BusinessExceptionDesc("10008", "角色删除失败，没有用户属于此角色");

        public static final BusinessExceptionDesc SYS_USER_EXIST = new BusinessExceptionDesc("10008", "账户已存在");

        public static final BusinessExceptionDesc SYS_USER_NOT_EXIST = new BusinessExceptionDesc("10008", "账户不存在");

        public static final BusinessExceptionDesc SYS_LOGIN_EXPIRED = new BusinessExceptionDesc("10008", "登陆已过期,请重新登陆");

        public static final BusinessExceptionDesc SYS_PARAM_LOST = new BusinessExceptionDesc("10008", "缺少必填参数");

    }
````
异常直接抛出，不要try...catch...捕获
````
    ......
    if (user == null) {
        //没找到帐号
            throw new StandardBusinessException(ErrorCode.SYS_USER_NOT_EXIST);
    }
    ......
````
异常返回Json
````
    {
        "success":false,
        "resultCode":"10008",
        "message":"账户不存在",
        "time":"2020-12-03 19:31:29"
    }
````
使用统一异常方案，若配合使用Monitor监控插件，即可对每个请求的异常信息进行跟踪查询管理。
- 请求监控
![base_record.png](/tools/base_record.png)
- 异常详情
![base_exception.png](/tools/base_exception.png)


## Service规范和数据访问
1. 所有业务Service均需继承IBaseService接口和BaseService实现类。
编码规范为公司标准规范，及接口为XXXService，实现类为XXXServiceImpl。否则启动项目时，代码检查会抛出编码规范异常。
2. 框架采用MybatisPlus进行数据访问，若需要Mybatis支持请继承IMybatisService接口和MybatisService实现类，自动拥有增删查改分页等基本功能，无需*mapper.xml支持。
````
@Service
public class LoginServiceImpl extends BaseService implements LoginService {
````
3. 可使用EntityWrapper进行代码数据操作，无需xml配置。
````
    public List<SysDept> list(SysDeptParam sysDeptParam) {
        EntityWrapper<SysDept> entityWrapper = new EntityWrapper<>();
        entityWrapper.eq("parent_id", sysDeptParam.getParentId());
        return deptMapper.selectList(entityWrapper);
    }
````

## 分页配置
框架通过AOP方式自动对分页进行了处理，业务无需专门进行分页操作。
1.项目中导入Page对象，注意导入路径为com.ichinae.core.plugins.common.model.page
````
import Page;
````

2.mapper层或Service层对需要分页的查询方法以“ByPage”结尾，并且入参必须有一个为Page的子类，AOP会根据Service实现类的方法ByPage后缀和page入参进行切入做分页处理，controller不做任何分页处理。

````
    public Page<McRequestRecord> listByPage(McRecordParam mcRecordParam) {

        mcRequestRecordMapper.selectByReq(mcRecordParam.getRequestRecordId());
        return mcRecordParam;
    }
````
如上面实例代码，入参McRecordParam必须继承Page类，传入PageNum和PageSize。返回值需要返回个Page对象，此处可直接将入参返回即可，框架会对返回值进行统一处理。
3.我们也可在Controller层，直接通过继承MybatisService父类的listByPage方法实现，Service不用写任何分页代码。
````
    @GetMapping("/list")
    @ApiOperation(value = "查询系统参数列表", notes = "查询系统参数列表")
    public Response<Page<SysLog>> listParam(SysLogParam sysLog){
        EntityWrapper<SysLog> entityWrapper = new EntityWrapper<>();
        Page<SysLog> list = logService.selectByPage(new EntityWrapper<SysLog>(), sysLog);
        return Response.data(list);
    }
````
## 跨域配置
框架支持前后端分离部署，支持跨域访问请求。跨域配置生效需在application-dev.properties 中配置
````
   cors.enable=true
````

## 多线程与后台任务
1. 继承BackgroundTask来定义后台任务，重写其execute方法。
````
/**
 * 后台任务接口
 * 
 * @param <V>
 */
public interface IBackgroundTask<V> extends Callable<V> {
		
	/**
	 * 执行任务
	 * 
	 * @return
	 * @throws Exception
	 */
	V execute() throws Exception;
}
````
````
@Component("requestMonitorDispatcherTask")
@Scope("prototype")
public class RequestMonitorDispatcherTask extends BackgroundTask<Void>
{ 
        ...
        @Override
        public Void execute() throws Exception {
            dispatchRequestMonitorData();
            return null;
        }
        ...
}
````
2. 需要使用后台任务的业务类中，添加任务执行器BackgroundTaskExecutorService。
````
@Autowired
private BackgroundTaskExecutorService backgroundTaskExecutorService;
````
3. 启动后台任务
````
// 创建任务对象，并纳入Spring上下文中，可以使用任务内的Spring Autowired注解对象。
RequestMonitorDispatcherTask dispatcherTask = this.getApplicationContext().getBean("requestMonitorDispatcherTask", RequestMonitorDispatcherTask.class);
dispatcherTask.setMonitorData(event.getSource()); // 传递业务数据
backgroundTaskExecutorService.submit(dispatcherTask); // 启动任务
````

## 事件机制
框架提供Spring Event事件处理解决方案，通过SystemEventDriver进行事件驱动管理。具体实现需参考以下三步：
1. 定义事件源Event，需要和对应事件监听器处理事件保持一致。
2. 业务事件监听器需继承BaseEventListener基础事件监听器，添加@Component注解确保纳入Spring上下文中，并重写其onFire监听方法进行业务处理。如下例请求事件监听器代码：
````
@Component
public class RequesMonitorListener extends BaseEventListener
{
    ...
    // 后台任务处理服务
	@Autowired
	private BackgroundTaskExecutorService backgroundTaskExecutorService;
    ...

    // 事件监听方法
	public void onFire(BaseEvent event, ListenerChain chain, ApplicationContext applicationContext, ServletContext servletContext)
			throws Exception
	{
        // 启动异步后台任务，并放入Spring上下文中
		RequestMonitorDispatcherTask dispatcherTask = this.getApplicationContext().getBean("requestMonitorDispatcherTask", RequestMonitorDispatcherTask.class);
		dispatcherTask.setMonitorData(event.getSource());
		backgroundTaskExecutorService.submit(dispatcherTask);
		chain.stop();
	}

    // 根据事件源过滤事件
	protected boolean isFilterEvent(Object eventSource)
	{
		// ....
		return false;
	}

    // 获取全局事件名称
	@Override
	public String getListenEventName() {
		return "_MONITOR";
	}
}
````
3. 业务根据需要调用框架BaseComponent封装的publishEvent方法抛出事件，触发事件机制。

## 微服务支持
框架全面支持SpringCloud Alibaba框架，对应版本为Spring Cloud Alibaba 2.1.0.RELEASE。
后续根据需要会退出对于K8S的微服务调用解决方案。

## 日志管理
框架采用logback进行日志采集管理，对Windows及Linux均支持灵活配置。
具体配置如下：
1. 在yml配置文件中配置日志文件及部署路径，如下例所示，配置文件名为logback-spring.xml，改文件在资源文件中配置。部署后日志的生成路径为/log文件夹下。
````
logging:
  config: classpath:logback-spring.xml
  path: ./logs
````
2. logback-spring.xml配置可从脚手架中获取，一般不用修改。
````
    <?xml version="1.0" encoding="UTF-8"?>
    <configuration scan="true" scanPeriod="600 seconds" debug="false">
        <!-- 取配置文件中的logging.appender的值，Console或者File,大小写不敏感，如果没有配置这个值，那么windows下是控制台打印，linux下是文件记录 -->
        <springProperty name="appender-ref" source="logging.appender"/>
        <springProperty name="rootLevel" source="logging.level.root" defaultValue="INFO"/>
        <springProperty name="applicationName" source="spring.application.name"/>
        <springProperty name="profilesActive" source="spring.profiles.active"/>
        <springProperty name="logging.pattern" source="logging.pattern"
                        defaultValue="%d [${applicationName}] [%thread] %-5level %c{10} - %msg%n"/>
        <!-- Windows系统下，或者 appender-ref的值小写是console，则输出到控制台 -->
        <if condition='(!"file".equals(p("appender-ref").toLowerCase()) &amp;&amp; p("os.name").contains("Windows"))
                        || "console".equals(p("appender-ref").toLowerCase())'>
            <then>
                <!-- 取springboot环境变量中logging.path的值，如果没有，默认在当前工程目录的log下输出日志 -->
                <springProperty name="logPath" source="logging.path" defaultValue="D:/log/${applicationName}"/>
                <springProperty name="logging.file.maxFileSize" source="logging.file.maxFileSize"
                                defaultValue="100MB"/>
                <springProperty name="logging.file.maxHistory" source="logging.file.maxHistory" defaultValue="3"/>
                <springProperty name="logging.file.totalSizeCap" source="logging.file.totalSizeCap"
                                defaultValue="1GB"/>
                <!-- 生产开始 -->
                <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
                    <File>${logPath}/${applicationName}.log</File>
                    <!-- 日志文件开启卷存 -->
                    <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
                        <FileNamePattern>${logPath}/%d{yyyy-MM-dd}.%i.log</FileNamePattern>
                        <maxFileSize>${logging.file.maxFileSize}</maxFileSize>
                        <maxHistory>${logging.file.maxHistory}</maxHistory>
                        <totalSizeCap>${logging.file.totalSizeCap}</totalSizeCap>
                    </rollingPolicy>
                    <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
                        <pattern>${logging.pattern}</pattern>
                    </encoder>
                </appender>
                <!-- 控制台输出 -->
                <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
                    <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
                        <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
                        <!-- pattern 格式说明 http://aub.iteye.com/blog/1103685 -->
                        <pattern>${logging.pattern}</pattern>
                    </encoder>
                </appender>
                <!-- 具体包的日志级别在application.properties中配置，不在这里指定 -->
                <root level="${rootLevel}">
                    <appender-ref ref="Console"/>
                    <appender-ref ref="FILE"/>
                </root>
            </then>
            <!-- =================================以下是服务器上用的配置 =================================  -->
            <else>
                <!-- 取springboot环境变量中logging.path的值，如果没有，默认在当前工程目录的log下输出日志 -->
                <springProperty name="logPath" source="logging.path" defaultValue="/tmp/log/${applicationName}"/>
                <springProperty name="logging.file.maxFileSize" source="logging.file.maxFileSize"
                                defaultValue="100MB"/>
                <springProperty name="logging.file.maxHistory" source="logging.file.maxHistory" defaultValue="3"/>
                <springProperty name="logging.file.totalSizeCap" source="logging.file.totalSizeCap"
                                defaultValue="1GB"/>
                <!-- 生产开始 -->
                <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
                    <File>${logPath}/${applicationName}.log</File>
                    <!-- 日志文件开启卷存 -->
                    <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
                        <FileNamePattern>${logPath}/back/%d{yyyy-MM-dd}.%i.log</FileNamePattern>
                        <maxFileSize>${logging.file.maxFileSize}</maxFileSize>
                        <maxHistory>${logging.file.maxHistory}</maxHistory>
                        <totalSizeCap>${logging.file.totalSizeCap}</totalSizeCap>
                    </rollingPolicy>
                    <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
                        <pattern>${logging.pattern}</pattern>
                    </encoder>
                </appender>

                <!-- 生产结束 -->
                <!-- 具体包的日志级别在application.properties中配置，不在这里指定 -->
                <logger name="org.apache" level="WARN"/>
                <logger name="org.springframework" level="WARN"/>
                <logger name="com.alibaba.nacos" level="WARN"/>
                <root level="${rootLevel}">
                    <appender-ref ref="FILE"/>
                </root>
            </else>
        </if>
    </configuration>
````
